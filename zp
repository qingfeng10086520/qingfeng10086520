#!/bin/bash

# 检查是否安装了 Python3
if ! command -v python3 &> /dev/null
then
    echo "错误: Python3 未安装。请安装 Python3 后重试。"
    exit 1
fi

# 检查 tqdm 是否已安装
if ! python3 -c "import tqdm" &> /dev/null
then
    echo "错误: 'tqdm' 模块未安装。请运行 'pip install tqdm' 后重试。"
    exit 1
fi

# 提示用户输入原版的 .dat 文件的完整路径
read -p "请输入原版的 .dat 文件的完整路径: " original_file 

# 检查用户是否输入了路径
if [ -z "$original_file" ]; then
    echo "错误: 未输入文件路径。"
    exit 1
fi

# 检查输入路径是否为一个文件
if [ ! -f "$original_file" ]; then
    echo "错误: 文件 '$original_file' 不存在。"
    exit 1
fi

# 如果需要，可以在这里添加对文件的进一步操作
echo "文件 '$original_file' 存在。"

# 提示用户输入要提取配置的 .dat 文件的完整路径
read -p "请输入提取配置的 .dat 文件的完整路径: " modified_file 

# 检查用户是否输入了路径
if [ -z "$modified_file" ]; then
    echo "错误: 未输入文件路径。"
    exit 1
fi

# 检查输入路径是否为一个文件
if [ ! -f "$modified_file" ]; then
    echo "错误: 文件 '$modified_file' 不存在。"
    exit 1
fi

# 如果需要，可以在这里添加对文件的进一步操作
echo "文件 '$original_file' 存在。"

# 使用 heredoc 将 Python 代码嵌入到 Shell 脚本中，并传递用户输入的目录路径
python3 << END_PYTHON
import re
import os
from tqdm import tqdm

def compare_files(original_file_path, modified_file_path, output_path):
    try:
        with open(original_file_path, 'rb') as f1, open(modified_file_path, 'rb') as f2:
            data1 = f1.read()
            data2 = f2.read()
    except FileNotFoundError as e:
        print(f"文件未找到: {e}")
        return
    except IOError as e:
        print(f"文件读取错误: {e}")
        return

    min_length = min(len(data1), len(data2))
    differences = []

    # 使用 tqdm 添加进度条
    for i in tqdm(range(min_length), desc="比较进度", unit="字节"):
        if data1[i] != data2[i]:
            # 检查前面第9,10,11,12个字节是否为0x04
            if i >= 9 and data1[i - 9] == 0x04:
                # 保存差异字节及其后三个字节
                chunk1 = data1[i:i + 4]
                chunk2 = data2[i:i + 4]
                differences.append((i - 9, chunk1, chunk2))
            elif i >= 10 and data1[i - 10] == 0x04:
                # 保存前一字节、差异字节及其后两个字节
                chunk1 = data1[i - 1:i + 3]
                chunk2 = data2[i - 1:i + 3]
                differences.append((i - 10, chunk1, chunk2))
            elif i >= 11 and data1[i - 11] == 0x04:
                # 保存前两字节、差异字节及其后一个字节
                chunk1 = data1[i - 2:i + 2]
                chunk2 = data2[i - 2:i + 2]
                differences.append((i - 11, chunk1, chunk2))
            elif i >= 12 and data1[i - 12] == 0x04:
                # 保存前三字节及差异字节本身
                chunk1 = data1[i - 3:i + 1]
                chunk2 = data2[i - 3:i + 1]
                differences.append((i - 12, chunk1, chunk2))
            # 如果不满足任何条件，则跳过

    if differences:
        with open(output_path, 'w') as out_file:
            for pos, chunk1, chunk2 in differences:
                # 将字节转换为十六进制字符串
                hex_str1 = ''.join(f'{b:02X}' for b in chunk1)
                hex_str2 = ''.join(f'{b:02X}' for b in chunk2)
                # 保存格式为 original_file 的差异值 modified_file 的差异值
                out_file.write(f"{hex_str1} {hex_str2}\n")
    else:
        print("未找到差异或差异不符合条件。")

    # 读取文件并存储唯一的行，优先保留第一次出现的行
    seen = set()
    unique_lines = []

    with open(output_path, 'r', encoding='utf-8') as file:
        for line in file:
            # 去除行首尾的空白字符并按空格分割
            parts = line.strip().split()
            # 对分割后的部分进行排序，以确保顺序一致
            sorted_parts = sorted(parts)
            # 将排序后的部分重新组合成一个字符串
            unique_line = ' '.join(sorted_parts)
            # 如果该行尚未被处理过，则添加到结果中
            if unique_line not in seen:
                seen.add(unique_line)
                unique_lines.append(line.strip())

    # 将唯一的行写入新的文件
    unique_output_path = '提取结果.txt'
    with open(unique_output_path, 'w', encoding='utf-8') as file:
        for line in unique_lines:
            file.write(line + '\n')

    # 将结果转换为十进制并保存到新的文件
    convert_hex_pairs_to_decimal(unique_output_path, '提取结果.txt')

    # 将注释信息添加到 提取结果.txt
    add_comments_to_提取结果txt('naixu/代码表.txt', '提取结果.txt', '提取结果.txt')

def convert_hex_pairs_to_decimal(input_file, output_file):
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            hex_lines = f.readlines()
        
        total_lines = len(hex_lines)
        with open(output_file, 'w', encoding='utf-8') as f:
            for line in hex_lines:
                # 去除空白字符和换行符
                line = line.strip()
                if not line:
                    continue  # 跳过空行
                
                # 分割每行的两个十六进制数
                hex_parts = line.split()
                if len(hex_parts) != 2:
                    print(f"Skipping invalid line (expected 2 hex values): {line}")
                    continue  # 跳过格式不正确的行
                
                # 分别处理两个十六进制数
                for hex_str in hex_parts:
                    hex_str = hex_str.strip().replace(" ", "")
                    if len(hex_str) % 2 != 0:
                        print(f"Skipping invalid hex string: {hex_str}")
                        continue  # 跳过无效的十六进制字符串
                    
                    # 将十六进制字符串转换为字节
                    byte_data = bytes.fromhex(hex_str)
                    
                    # 根据字节长度确定字节序（小端序）
                    if len(byte_data) == 4:
                        # 4字节转换为整数（小端序）
                        number = int.from_bytes(byte_data, byteorder='little')
                    elif len(byte_data) == 2:
                        # 2字节转换为整数（小endian）
                        number = int.from_bytes(byte_data, byteorder='little')
                    else:
                        print(f"Unsupported byte length for hex string: {hex_str}")
                        number = None
                    
                    if number is not None:
                        f.write(f"{number} ")
                f.write("\n")  # 每行写完两个数后换行 
    
    except FileNotFoundError as e:
        print(f"文件未找到: {e}")
    except Exception as e:
        print(f"发生错误: {e}")

def add_comments_to_提取结果txt(z_file, four_file, result_file):
    # 读取 z.txt 并存储在字典中，键为数字，值为注释信息
    comment_dict = {}
    with open(z_file, 'r', encoding='utf-8') as zf:
        for line in zf:
            line = line.strip()
            if line:
                # 使用正则表达式提取数字和注释信息
                match = re.match(r'\d+\s*--\s*(\d+)\s*--\s*(.*?)\s*--\s*(.*)', line)
                if match:
                    number, comment1, comment2 = match.groups()
                    comment_dict[number] = comment1  # 提取第二个注释

    # 读取 提取结果.txt 并存储在列表中
    with open(four_file, 'r', encoding='utf-8') as tf:
        lines = [line.strip() for line in tf if line.strip()]

    # 更新 提取结果.txt 的内容
    updated_lines = []
    for line in lines:
        # 使用正则表达式提取两组数字
        match = re.match(r'(\d+)\s+(\d+)', line)
        if match:
            first_number, second_number = match.groups()
            # 获取第一组数字的注释
            first_comment = comment_dict.get(first_number, '')
            # 获取第二组数字的注释
            second_comment = comment_dict.get(second_number, '')
            if first_comment and second_comment:
                # 构建新的行内容
                updated_line = f" #{first_comment}, {second_comment}\n"
                updated_lines.append(updated_line)
            else:
                # 如果没有找到对应的注释，则保持原样
                updated_lines.append(f"{line}\n")
        else:
            # 如果行格式不正确，则保持原样
            updated_lines.append(f"{line}\n")

    # 将更新后的内容写回 提取结果.txt
    with open(result_file, 'w', encoding='utf-8') as rf:
        rf.writelines(updated_lines)
    
    print(f"提取的美化配置已保存到 {result_file}")

if __name__ == "__main__":
    # 定义原版dat防止eof
    original_file = '$original_file'
    # 定义要提取的dat防止eof
    modified_file = '$modified_file'
    
    # 设置输出文件的默认路径为当前目录下的 output.txt
    output_file = '提取结果.txt'
    
    # 验证输入的文件是否存在
    import os

    if not os.path.isfile(original_file):
        print(f"错误: 文件 '{original_file}' 不存在。请检查路径并重试。")
    elif not os.path.isfile(modified_file):
        print(f"错误: 文件 '{modified_file}' 不存在。请检查路径并重试。")
    else:
        compare_files(original_file, modified_file, output_file)
END_PYTHON